## Tool: Generate Persistence Code (Spring Data JPA for PostgreSQL)

### Purpose

Generate the Java persistence layer for a domain entity using Spring Data JPA on PostgreSQL. Produce compilable source that maps the project’s JSON schema to JPA entities, repositories, and a service layer, aligned with the Codex session context and existing DB migrations.

---

### Inputs

Load Codex session context.

* Project

    * Name
    * Author
* Maven

    * groupId
    * artifactId
* Domain

    * Domain Object (singular, e.g., Customer)
    * Persisted Data schema (path to JSON schema)
* Tech assumptions (implicit unless overridden)

    * Java 21, Spring Boot 3.5.x, Hibernate 6.x, PostgreSQL 16

---

### Constraints

* Use `jakarta.persistence.*` and `jakarta.validation.*`.
* Map JSON field names to snake\_case DB column names.
* Prefer `UUID` primary keys; use `@JdbcTypeCode(SqlTypes.UUID)` where applicable.
* Do not modify packages under `health`.
* Respect existing DDL generated by DB tools (do not rename tables/columns that would drift from migrations).
* `open-in-view: false` assumed; no lazy loading in controller layer required by this tool.

---

### Behavior

1. Parse the Persisted Data schema to derive entity fields, nullability, lengths, uniques, and FKs.
2. Emit:

    * A JPA `@Entity` with `@Table`, `@Column`, PK, and FK mappings.
    * A Spring Data `JpaRepository<Entity, IdType>`.
    * A Service class with transactional CRUD and simple uniqueness guards (where indicated by schema).
    * Optional mappers/DTOs only if the schema requires value-object flattening for aggregates.
3. Maintain alignment with prior DB migrations (table names, column names, constraints).
4. Generate null-safe getters and validation annotations consistent with schema.

---

### Deliverables (create or update)

* `src/main/java/{{groupIdPath}}/{{artifactId}}/{{Domain}}.java`

    * `@Entity`, `@Table(name = "<table_name>")`
    * Fields from schema with `@Column(name = "...", nullable = ..., length = ...)`
    * PK: `UUID id` with `@Id`, `@GeneratedValue`, `@JdbcTypeCode(SqlTypes.UUID)`
    * Timestamps (if not in schema): `created_at`, `updated_at` via `@CreationTimestamp`, `@UpdateTimestamp` (optional)
    * Unique constraints as `@UniqueConstraint` or column-level `unique = true` when appropriate
    * Relationships mapped via `@ManyToOne`, `@OneToMany`, etc., only if indicated by schema
* `src/main/java/{{groupIdPath}}/{{artifactId}}/{{Domain}}Repository.java`

    * `interface {{Domain}}Repository extends JpaRepository<{{Domain}}, UUID>`
    * Convenience finders inferred from unique fields (e.g., `findByEmail`, `existsByEmail`)
* `src/main/java/{{groupIdPath}}/{{artifactId}}/{{Domain}}Service.java`

    * Methods: `create`, `get`, `list`, `update`, `delete`
    * `@Transactional` boundaries; uniqueness validation prior to writes
    * Converts to/from simple DTOs when required; otherwise returns entity
* (Optional) DTOs if schema types or nested objects benefit from separation:

    * `.../api/{{Domain}}Dto.java` with `CreateRequest`, `UpdateRequest`, `Response`

Where `{{groupIdPath}}` is `{{groupId}}` with dots replaced by slashes.

---

### Mapping Rules

* JSON `string` → Java `String` (apply `@Size(max = n)` if `maxLength` present)
* JSON `string (format: uuid)` → Java `UUID` with `@JdbcTypeCode(SqlTypes.UUID)`
* JSON `boolean` → `Boolean`/`boolean`
* JSON numeric types → `Integer`, `Long`, `BigDecimal` based on `format`/range hints when present
* Required fields → `@NotNull`/`@NotBlank` (text) and `nullable = false` in `@Column`
* `enum` → `@Enumerated(EnumType.STRING)` with generated `enum` type in same package
* Arrays/collections in schema → separate child entity mapped `@OneToMany` with FK, only if the DB DDL establishes a separate table
* Email fields → add `@Email` when field name or schema format indicates email

---

### Output Format

On success, return a JSON object with file list and contents suitable for writing to disk:

```json
{
  "status": "success",
  "files": [
    {"path": "src/main/java/{{groupIdPath}}/{{artifactId}}/{{Domain}}.java", "content": "..."},
    {"path": "src/main/java/{{groupIdPath}}/{{artifactId}}/{{Domain}}Repository.java", "content": "..."},
    {"path": "src/main/java/{{groupIdPath}}/{{artifactId}}/{{Domain}}Service.java", "content": "..."}
  ]
}
```

On failure:

```json
{
  "status": "failure",
  "error": "reason message"
}
```

---

### Workflow

1. Load Codex session context.
2. Read Persisted Data schema.
3. Determine PK, uniques, nullability, lengths, and relationships from schema (and, if present, `x-db.*` hints).
4. Render Java sources using the mapping rules and constraints.
5. Validate that generated names and types match existing DB DDL conventions (if DB tool artifacts are available).
6. Emit output files.

---

### Acceptance Criteria

* Code compiles under Java 21 and Spring Boot 3.5.x with JPA/Hibernate 6.
* Entity/table/column names match DB migrations (no drift).
* Required fields enforced via annotations and column nullability.
* Repository provides at least one convenience finder for unique fields.
* Service methods are transactional and enforce uniqueness where specified.
* No changes to non-persistence packages (e.g., `health`) are made.

---

### Example Invocation (from context)

* Domain Object: `Customer`
* Persisted Data schema: `project_root/ai/agentic-pipeline/context/schemas/customer.schema.json`
* Maven:

    * groupId: `com.bobwares.customer`
    * artifactId: `registration`

Expected files under:

* `src/main/java/com/bobwares/customer/registration/Customer.java`
* `src/main/java/com/bobwares/customer/registration/CustomerRepository.java`
* `src/main/java/com/bobwares/customer/registration/CustomerService.java`
